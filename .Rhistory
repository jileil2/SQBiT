####### coordinates
S.pop <- pop.r[, c(1, 2)]
u <- unique(round(S.pop[, 1], 2))
v <- unique(round(S.pop[, 2], 2))
####### coefficient functions
beta1 <- function(s1, s2) sin(pi * s1 * s2)
beta2 <- function(s1, s2) (1 - (1 - 2 * s1) ^ 2) * (1 - (1 - 2 * s2) ^ 2)
####### population data
pop.r <- cbind(S.pop, beta1(S.pop[, 1], S.pop[, 2]), beta2(S.pop[, 1], S.pop[, 2]))
colnames(pop.r)[3:4] <- c('beta0', 'beta1')
####### Population basis
d <- 3 # d = degree of piecewise polynomials
r <- 1 # r = smoothness parameters
B0.pop <- basis(V = V, Tr = Tr,
d = d, r = r,
Z = as.matrix(S.pop))
Q2 <- B0.pop$Q2 ###### QR decomposition of the smoothness matrix
B.pop <- B0.pop$B
####### penalty
K <- B0.pop$K
P <- t(Q2) %*% K %*% Q2
####### simulation
n <- 2000   ## sample size
tau <- 0.5  ## quantile level
####### simulating covariates with constant effects
eta <- matrix(c(1, 1, 1))
Sigma <- diag(3)
####### sample a population
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
####### covariates
S <- data[, c(1, 2)] ## locations
C <- matrix(runif(3 * n, -1, 1), ncol = 3) ## covariates that have constant effects
X <- matrix(runif(n, -1, 1), n, 1) ## covariates that have varying effects
####### simulate the response
beta0 <- data[, c('beta0', 'beta1')]
Y <- beta0[, 1] + X[, 1] * beta0[, 2] + C %*% eta + rnorm(n = n)
####### generate Bivariate spline basis
X <- cbind(1, X)
B <- B.pop[ind.s, ] ## basis functions
####### SQBiT for a given penalization parameter lambda
mod <- SQBiT(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2,
lambda = 0.1,
tau = tau)
devtools::document()
devtools::install()
library('SQBiT')
####### construct a triangulation for a rectangular domain
boundaries <- matrix(c(0, 0,
0, 1,
1, 1,
1, 0), nrow = 4, byrow = TRUE)
tri <- TriMesh(boundaries, n = 8)
devtools::document()
devtools::install()
library('SQBiT')
####### construct a triangulation for a rectangular domain
boundaries <- matrix(c(0, 0,
0, 1,
1, 1,
1, 0), nrow = 4, byrow = TRUE)
tri <- TriMesh(boundaries, n = 8)
Tr <- tri$Tr
V <- round(tri$V, 3)
####### population locations
s1 <- runif(10000)
s2 <- runif(10000)
S_pop <- data.frame(s1 = s1, s2 = s2)
####### determine a point is inside a given triangulation
ind1 <- inVT(V0 = V, Tr0 = Tr,
xx = S_pop[, 1], yy = S_pop[, 2])
####### indices of all the points which are inside the triangulation
ind1 <- ind1$ind.inside
ind2 <- (1:nrow(S_pop))[!is.na(S_pop[, 1])]
ind <- sort(intersect(ind1, ind2))
pop.r <- S_pop[ind, ]
Npop <- nrow(pop.r)
####### coordinates
S.pop <- pop.r[, c(1, 2)]
u <- unique(round(S.pop[, 1], 2))
v <- unique(round(S.pop[, 2], 2))
####### coefficient functions
beta1 <- function(s1, s2) sin(pi * s1 * s2)
beta2 <- function(s1, s2) (1 - (1 - 2 * s1) ^ 2) * (1 - (1 - 2 * s2) ^ 2)
####### population data
pop.r <- cbind(S.pop, beta1(S.pop[, 1], S.pop[, 2]), beta2(S.pop[, 1], S.pop[, 2]))
colnames(pop.r)[3:4] <- c('beta0', 'beta1')
####### Population basis
d <- 3 # d = degree of piecewise polynomials
r <- 1 # r = smoothness parameters
B0.pop <- basis(V = V, Tr = Tr,
d = d, r = r,
Z = as.matrix(S.pop))
Q2 <- B0.pop$Q2 ###### QR decomposition of the smoothness matrix
B.pop <- B0.pop$B
####### penalty
K <- B0.pop$K
P <- t(Q2) %*% K %*% Q2
####### simulation
n <- 2000   ## sample size
tau <- 0.5  ## quantile level
####### simulating covariates with constant effects
eta <- matrix(c(1, 1, 1))
Sigma <- diag(3)
####### sample a population
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
####### covariates
S <- data[, c(1, 2)] ## locations
C <- matrix(runif(3 * n, -1, 1), ncol = 3) ## covariates that have constant effects
X <- matrix(runif(n, -1, 1), n, 1) ## covariates that have varying effects
####### simulate the response
beta0 <- data[, c('beta0', 'beta1')]
Y <- beta0[, 1] + X[, 1] * beta0[, 2] + C %*% eta + rnorm(n = n)
####### generate Bivariate spline basis
X <- cbind(1, X)
B <- B.pop[ind.s, ] ## basis functions
####### SQBiT for a given penalization parameter lambda
mod <- SQBiT(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2,
lambda = 0.1,
tau = tau)
Rcpp::compileAttributes()
devtools::document()
devtools::install(clean = TRUE)
getNativeSymbolInfo("eigenMapMatMult", "SQBiT")
Rcpp::compileAttributes()
devtools::install(clean = TRUE)
library(SQBiT)
getNativeSymbolInfo("_SQBiT_eigenMapMatMult", "SQBiT")
library(SQBiT)
getNativeSymbolInfo("_SQBiT_eigenMapMatMult", "SQBiT")
# Make sure you are in your package root folder
# Regenerate Rcpp exports (do this every time you add/change C++ functions)
Rcpp::compileAttributes()
# Reinstall the package (forces rebuild)
devtools::install(clean = TRUE)
# Restart R session again, then load
library(SQBiT)
# Check symbol again
getNativeSymbolInfo("_SQBiT_eigenMapMatMult", "SQBiT")
devtools::document()
devtools::install()
####### construct a triangulation for a rectangular domain
boundaries <- matrix(c(0, 0,
0, 1,
1, 1,
1, 0), nrow = 4, byrow = TRUE)
tri <- TriMesh(boundaries, n = 8)
Tr <- tri$Tr
V <- round(tri$V, 3)
####### population locations
s1 <- runif(10000)
s2 <- runif(10000)
S_pop <- data.frame(s1 = s1, s2 = s2)
####### determine a point is inside a given triangulation
ind1 <- inVT(V0 = V, Tr0 = Tr,
xx = S_pop[, 1], yy = S_pop[, 2])
####### indices of all the points which are inside the triangulation
ind1 <- ind1$ind.inside
ind2 <- (1:nrow(S_pop))[!is.na(S_pop[, 1])]
ind <- sort(intersect(ind1, ind2))
pop.r <- S_pop[ind, ]
Npop <- nrow(pop.r)
####### coordinates
S.pop <- pop.r[, c(1, 2)]
u <- unique(round(S.pop[, 1], 2))
v <- unique(round(S.pop[, 2], 2))
####### coefficient functions
beta1 <- function(s1, s2) sin(pi * s1 * s2)
beta2 <- function(s1, s2) (1 - (1 - 2 * s1) ^ 2) * (1 - (1 - 2 * s2) ^ 2)
####### population data
pop.r <- cbind(S.pop, beta1(S.pop[, 1], S.pop[, 2]), beta2(S.pop[, 1], S.pop[, 2]))
colnames(pop.r)[3:4] <- c('beta0', 'beta1')
####### Population basis
d <- 3 # d = degree of piecewise polynomials
r <- 1 # r = smoothness parameters
B0.pop <- basis(V = V, Tr = Tr,
d = d, r = r,
Z = as.matrix(S.pop))
Q2 <- B0.pop$Q2 ###### QR decomposition of the smoothness matrix
B.pop <- B0.pop$B
####### penalty
K <- B0.pop$K
P <- t(Q2) %*% K %*% Q2
####### simulation
n <- 2000   ## sample size
tau <- 0.5  ## quantile level
####### simulating covariates with constant effects
eta <- matrix(c(1, 1, 1))
Sigma <- diag(3)
####### sample a population
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
####### covariates
S <- data[, c(1, 2)] ## locations
C <- matrix(runif(3 * n, -1, 1), ncol = 3) ## covariates that have constant effects
X <- matrix(runif(n, -1, 1), n, 1) ## covariates that have varying effects
####### simulate the response
beta0 <- data[, c('beta0', 'beta1')]
Y <- beta0[, 1] + X[, 1] * beta0[, 2] + C %*% eta + rnorm(n = n)
####### generate Bivariate spline basis
X <- cbind(1, X)
B <- B.pop[ind.s, ] ## basis functions
####### SQBiT for a given penalization parameter lambda
mod <- SQBiT(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2,
lambda = 0.1,
tau = tau)
devtools::document()
devtools::install()
library('SQBiT')
####### construct a triangulation for a rectangular domain
boundaries <- matrix(c(0, 0,
0, 1,
1, 1,
1, 0), nrow = 4, byrow = TRUE)
tri <- TriMesh(boundaries, n = 8)
Tr <- tri$Tr
V <- round(tri$V, 3)
####### population locations
s1 <- runif(10000)
s2 <- runif(10000)
S_pop <- data.frame(s1 = s1, s2 = s2)
####### determine a point is inside a given triangulation
ind1 <- inVT(V0 = V, Tr0 = Tr,
xx = S_pop[, 1], yy = S_pop[, 2])
####### indices of all the points which are inside the triangulation
ind1 <- ind1$ind.inside
ind2 <- (1:nrow(S_pop))[!is.na(S_pop[, 1])]
ind <- sort(intersect(ind1, ind2))
pop.r <- S_pop[ind, ]
Npop <- nrow(pop.r)
####### coordinates
S.pop <- pop.r[, c(1, 2)]
u <- unique(round(S.pop[, 1], 2))
v <- unique(round(S.pop[, 2], 2))
####### coefficient functions
beta1 <- function(s1, s2) sin(pi * s1 * s2)
beta2 <- function(s1, s2) (1 - (1 - 2 * s1) ^ 2) * (1 - (1 - 2 * s2) ^ 2)
####### population data
pop.r <- cbind(S.pop, beta1(S.pop[, 1], S.pop[, 2]), beta2(S.pop[, 1], S.pop[, 2]))
colnames(pop.r)[3:4] <- c('beta0', 'beta1')
####### Population basis
d <- 3 # d = degree of piecewise polynomials
r <- 1 # r = smoothness parameters
B0.pop <- basis(V = V, Tr = Tr,
d = d, r = r,
Z = as.matrix(S.pop))
Q2 <- B0.pop$Q2 ###### QR decomposition of the smoothness matrix
B.pop <- B0.pop$B
####### penalty
K <- B0.pop$K
P <- t(Q2) %*% K %*% Q2
####### simulation
n <- 2000   ## sample size
tau <- 0.5  ## quantile level
####### simulating covariates with constant effects
eta <- matrix(c(1, 1, 1))
Sigma <- diag(3)
####### sample a population
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
####### covariates
S <- data[, c(1, 2)] ## locations
C <- matrix(runif(3 * n, -1, 1), ncol = 3) ## covariates that have constant effects
X <- matrix(runif(n, -1, 1), n, 1) ## covariates that have varying effects
####### simulate the response
beta0 <- data[, c('beta0', 'beta1')]
Y <- beta0[, 1] + X[, 1] * beta0[, 2] + C %*% eta + rnorm(n = n)
####### generate Bivariate spline basis
X <- cbind(1, X)
B <- B.pop[ind.s, ] ## basis functions
####### SQBiT for a given penalization parameter lambda
mod <- SQBiT(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2,
lambda = 0.1,
tau = tau)
devtools::document()
devtools::install()
library('SQBiT')
####### construct a triangulation for a rectangular domain
boundaries <- matrix(c(0, 0,
0, 1,
1, 1,
1, 0), nrow = 4, byrow = TRUE)
tri <- TriMesh(boundaries, n = 8)
Tr <- tri$Tr
V <- round(tri$V, 3)
####### population locations
s1 <- runif(10000)
s2 <- runif(10000)
S_pop <- data.frame(s1 = s1, s2 = s2)
####### determine a point is inside a given triangulation
ind1 <- inVT(V0 = V, Tr0 = Tr,
xx = S_pop[, 1], yy = S_pop[, 2])
####### indices of all the points which are inside the triangulation
ind1 <- ind1$ind.inside
ind2 <- (1:nrow(S_pop))[!is.na(S_pop[, 1])]
ind <- sort(intersect(ind1, ind2))
pop.r <- S_pop[ind, ]
Npop <- nrow(pop.r)
####### coordinates
S.pop <- pop.r[, c(1, 2)]
u <- unique(round(S.pop[, 1], 2))
v <- unique(round(S.pop[, 2], 2))
####### coefficient functions
beta1 <- function(s1, s2) sin(pi * s1 * s2)
beta2 <- function(s1, s2) (1 - (1 - 2 * s1) ^ 2) * (1 - (1 - 2 * s2) ^ 2)
####### population data
pop.r <- cbind(S.pop, beta1(S.pop[, 1], S.pop[, 2]), beta2(S.pop[, 1], S.pop[, 2]))
colnames(pop.r)[3:4] <- c('beta0', 'beta1')
####### Population basis
d <- 3 # d = degree of piecewise polynomials
r <- 1 # r = smoothness parameters
B0.pop <- basis(V = V, Tr = Tr,
d = d, r = r,
Z = as.matrix(S.pop))
Q2 <- B0.pop$Q2 ###### QR decomposition of the smoothness matrix
B.pop <- B0.pop$B
####### penalty
K <- B0.pop$K
P <- t(Q2) %*% K %*% Q2
####### simulation
n <- 2000   ## sample size
tau <- 0.5  ## quantile level
####### simulating covariates with constant effects
eta <- matrix(c(1, 1, 1))
Sigma <- diag(3)
####### sample a population
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
####### covariates
S <- data[, c(1, 2)] ## locations
C <- matrix(runif(3 * n, -1, 1), ncol = 3) ## covariates that have constant effects
X <- matrix(runif(n, -1, 1), n, 1) ## covariates that have varying effects
####### simulate the response
beta0 <- data[, c('beta0', 'beta1')]
Y <- beta0[, 1] + X[, 1] * beta0[, 2] + C %*% eta + rnorm(n = n)
####### generate Bivariate spline basis
X <- cbind(1, X)
B <- B.pop[ind.s, ] ## basis functions
####### SQBiT for a given penalization parameter lambda
mod <- SQBiT(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2,
lambda = 0.1,
tau = tau)
devtools::document()
devtools::document()
####### Step 1. Create a Triangulation Mesh
#######
####### construct a triangulation for a rectangular domain
boundaries <- matrix(c(0, 0,
0, 1,
1, 1,
1, 0), nrow = 4, byrow = TRUE)
tri <- TriMesh(boundaries, n = 8)
Tr <- tri$Tr
V <- round(tri$V, 3)
####### population locations
s1 <- runif(10000)
s2 <- runif(10000)
S_pop <- data.frame(s1 = s1, s2 = s2)
####### determine a point is inside a given triangulation
ind1 <- inVT(V0 = V, Tr0 = Tr,
xx = S_pop[, 1], yy = S_pop[, 2])
####### indices of all the points which are inside the triangulation
ind1 <- ind1$ind.inside
ind2 <- (1:nrow(S_pop))[!is.na(S_pop[, 1])]
ind <- sort(intersect(ind1, ind2))
pop.r <- S_pop[ind, ]
Npop <- nrow(pop.r)
####### coordinates
S.pop <- pop.r[, c(1, 2)]
u <- unique(round(S.pop[, 1], 2))
v <- unique(round(S.pop[, 2], 2))
####### coefficient functions
beta1 <- function(s1, s2) sin(pi * s1 * s2)
beta2 <- function(s1, s2) (1 - (1 - 2 * s1) ^ 2) * (1 - (1 - 2 * s2) ^ 2)
####### population data
pop.r <- cbind(S.pop, beta1(S.pop[, 1], S.pop[, 2]), beta2(S.pop[, 1], S.pop[, 2]))
colnames(pop.r)[3:4] <- c('beta0', 'beta1')
####### Step 2. Generate bivariate triangulation basis
#######
####### Population basis
d <- 3 # d = degree of piecewise polynomials
r <- 1 # r = smoothness parameters
B0.pop <- basis(V = V, Tr = Tr,
d = d, r = r,
Z = as.matrix(S.pop))
Q2 <- B0.pop$Q2 ###### QR decomposition of the smoothness matrix
B.pop <- B0.pop$B
BQ2.pop <- as.matrix(B.pop %*% Q2) ## basis function for population locations
####### penalty
K <- B0.pop$K
P <- t(Q2) %*% K %*% Q2
####### simulation
n <- 2000   ## sample size
tau <- 0.5  ## quantile level
####### simulating covariates with constant effects
eta <- matrix(c(1, 1, 1))
Sigma <- diag(3)
####### sample a population
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
####### covariates
S <- data[, c(1, 2)] ## locations
C <- matrix(runif(3 * n, -1, 1), ncol = 3) ## covariates that have constant effects
X <- matrix(runif(n, -1, 1), n, 1) ## covariates that have varying effects
####### simulate the response
beta0 <- data[, c('beta0', 'beta1')]
Y <- beta0[, 1] + X[, 1] * beta0[, 2] + C %*% eta + rnorm(n = n)
####### generate Bivariate spline basis
X <- cbind(1, X)
B <- B.pop[ind.s, ] ## basis functions
# dimension
p <- ncol(C)
n <- length(Y)
rlt = 7
# base model with all constant effects
h.base <- rlt * tau * (1 - tau) * ((p + dim(Q2)[2] * 1 + log(n)) / n) ^ (2/5)
mod.base <- SQBiT_gacv(Y = Y, X = matrix(1, nrow = n), C = cbind(C, X),
P = P, B = B, Q2 = Q2,
nlambda = nlambda, new.nlambda = nlambda,
lambda_start = lambda_start, lambda_end = lambda_end,
lambda.scale = lambda.scale,
h = h.base, tau = tau)
lambda_start = 1e-4
lambda_end = 1e1
lambda.scale = 100
mod.base <- SQBiT_gacv(Y = Y, X = matrix(1, nrow = n), C = cbind(C, X),
P = P, B = B, Q2 = Q2,
nlambda = nlambda, new.nlambda = nlambda,
lambda_start = lambda_start, lambda_end = lambda_end,
lambda.scale = lambda.scale,
h = h.base, tau = tau)
nlambda = 10
new.nlambda = 10
mod.base <- SQBiT_gacv(Y = Y, X = matrix(1, nrow = n), C = cbind(C, X),
P = P, B = B, Q2 = Q2,
nlambda = nlambda, new.nlambda = nlambda,
lambda_start = lambda_start, lambda_end = lambda_end,
lambda.scale = lambda.scale,
h = h.base, tau = tau)
cri.base <- mod.base$gacv.min
# forward selection
index.C <- 1:p
index.X <- c()
ms.cri <- vector('list', length = p + 1)
ms.cri[[1]] <- cri.base
t <- 1
while(p >= 1) {
cris <- c()
for (j in index.C) {
C.j <- C[, setdiff(index.C, j), drop = FALSE]
X.j <- cbind(1, C[, c(index.X, j)])
# make bandwidth adaptive to the dimensions
h.j <- rlt * tau * (1 - tau) * ((ncol(C.j) + dim(Q2)[2] * ncol(X.j) + log(n)) / n) ^ (2/5)
mod.j <- SQBiT_gacv(Y = Y, X = X.j, C = C.j,
P = P, B = B, Q2 = Q2,
nlambda = nlambda, new.nlambda = nlambda,
lambda_start = lambda_start, lambda_end = lambda_end,
lambda.scale = lambda.scale,
h = h.j, tau = tau)
cri.j <- mod.j$gacv.min
cris <- c(cris, cri.j)
}
t <- t + 1
ms.cri[[t]] <- cris
if (min(cris) > cri.base) {
break
}  else {
index.X <- c(index.X, index.C[which.min(cris)])
index.C <- index.C[-which.min(cris)]
}
cri.base <- min(cris)
p <- length(index.C)
}
qsm <- SQBiT_forward(tau = tau, Y = Y, C = cbind(C, X), P = P, B = B, Q2 = Q2)
eta.j1
dim(kp)
lambda.scale
lambda_start
nlambda
nlambda
lambda_end
ncol(C.j)
ncol(X.j)
h.j
mod.j <- SQBiT_gacv(Y = Y, X = X.j, C = C.j,
P = P, B = B, Q2 = Q2,
nlambda = nlambda, new.nlambda = nlambda,
lambda_start = lambda_start, lambda_end = lambda_end,
lambda.scale = lambda.scale,
h = h.j, tau = tau)
mod.j$gacv.min
head(X)
qsm <- SQBiT_forward(tau = tau, Y = Y, C = cbind(C, X[, -1]), P = P, B = B, Q2 = Q2)
qsm$constant
new.C <- XC[, qsm$constant]
new.X <- cbind(1, XC[, qsm$varying])
XC <- cbind(C, X[, -1])
new.C <- XC[, qsm$constant]
new.X <- cbind(1, XC[, qsm$varying])
mod <- SQBiT_gacv(Y = Y, X = new.X, C = XC[, qsm$constant], P = P, B = B, Q2 = Q2, tau = 0.90)
devtools::document()
devtools::install()
devtools::document()
devtools::install_github("jileil2/SQBiT")
devtools::install_github("jileil2/SQBiT")
library('SQBiT')
