#' k-fold Cross-Validation for SQBiT
#'
#' This function implements k-fold cross-validation for the quantile regression model with spatially varying coefficients, and returns the average check loss across folds.
#'
#' @param y A numeric response vector of length \code{n}, where \code{n} is the number of observations.
#' @param C A matrix of covariates with constant coefficients, of dimension \code{n} by \code{q}.
#' @param X A matrix of covariates with spatially varying coefficients, of dimension \code{n} by \code{p}.
#' @param B The B-spline basis matrix of dimension \code{n} by \code{K}, evaluated at spatial coordinates.
#' @param Q2 A penalty-related matrix generated by the \code{BPST::basis()} function.
#' @param P A penalty matrix from the spatial basis representation.
#' @param d Degree of piecewise polynomials; default is 3.
#' @param r Smoothness parameter; default is 1. Must satisfy \code{0 <= r < d}.
#' @param lambda A vector of candidate penalty parameters. Default is typically set to a sequence of log-scaled values.
#' @param nfold The number of folds in cross-validation; default is 5. Must be at least 3.
#' @param initial A numeric seed used for reproducibility; default is 2024.
#' @param tau Quantile level; default is 0.5 (median regression).
#' @param eta.j A scalar for adaptive penalty weight; default is 0.32.
#' @param h A bandwidth parameter used in model fitting.
#' @param var.j Logical. If \code{TRUE}, allows componentwise adaptive weights; default is \code{FALSE}.
#'
#' @return A numeric vector of check loss values, one for each fold.
#'
#' @details The function fits the model using \code{SQBiT()} on each training fold, predicts on the held-out set, and evaluates prediction error using the check loss function. The average of these losses estimates the predictive performance at the given \code{tau}.
#'
#' @importFrom BPST basis
#' @export
#'
#' @references
#' Kim, M., Wang, L., and Wang, H. J. (2025). Estimation and inference of quantile spatially varying coefficient models over complicated domains. *Journal of the American Statistical Association*, 1--15. Taylor & Francis. Forthcoming.
cv.pred.SQBiT = function(y, C, X, B, Q2, P, d = 3, r = 1, lambda, nfold = 5, initial = 2024,
                          tau = 0.50, eta.j = 0.32, h,
                          var.j = FALSE) {

  ####################################################
  n <- length(y)
  sfold <- round(n / nfold)
  set.seed(initial)
  Test <- sample(1:n)
  cv.error <- c()

  for(ii in 1:nfold){
    if(ii < nfold){
      Test.set = sort(Test[((ii - 1) * sfold + 1):(ii * sfold)])
    }
    if(ii == nfold){
      Test.set = sort(Test[((ii - 1) * sfold + 1):n])
    }
    Train.set = setdiff(1:n, Test.set)

    # consider univariate case / after using an index, it becomes a vector again above.
    if(is.vector(X) == 1){

      C.test <- as.matrix(C[Test.set, drop = FALSE])
      C.train <- as.matrix(C[Train.set, drop = FALSE])

      X.test <- as.matrix(X[Test.set])
      X.train <- as.matrix(X[Train.set])

    } else {

      C.test <- C[Test.set, , drop = FALSE]
      C.train <- C[Train.set, , drop = FALSE]

      X.test <- X[Test.set, ]
      X.train <- X[Train.set, ]
    }
    ###############################################
    B.test <- as.matrix(B[Test.set, ])
    B.train <- B[Train.set, ]
    # BQ2.test=BQ2[Test.set,]
    # BQ2.train=BQ2[Train.set,]
    ###############################################
    y.test <- y[Test.set]
    y.train <- y[Train.set]

    # model fit
    mfit.ii <- SQBiT(Y = y.train, C = C.train, X = X.train, B = B.train, Q2 = Q2, P = P,
                           lambda = lambda, tau = tau, eta.j = eta.j, var.j = var.j,
                           h = h, gacv.compute = FALSE)

    W.test <- as.matrix(kr(X.test, eigenMapMatMult(B.test, Q2), byrow = TRUE)) #B.test
    ypred.ii <- eigenMapMatMult(C.test, as.vector(mfit.ii$eta)) + eigenMapMatMult(W.test, as.vector(mfit.ii$gamma))

    ## prediction check loss
    pred.error <- mean(rhotau(u = y.test - ypred.ii, tau = tau))
    cv.error <- c(cv.error, pred.error)
  }
  cv.error
 }
