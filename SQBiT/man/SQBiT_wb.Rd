% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SQBiT_wb.R
\name{SQBiT_wb}
\alias{SQBiT_wb}
\title{Wild Bootstrap of Smoothed Quantile Bivariate Triangulation (SQBiT-WB)}
\usage{
SQBiT_wb(
  h = 7 * tau * (1 - tau) * ((ncol(C) + dim(Q2)[2] * ncol(X) +
    log(length(Y)))/length(Y))^(2/5),
  tau,
  Y,
  C,
  X,
  P,
  B,
  Q2,
  max.iter = 50,
  lambda,
  eps.abs = 1e-04,
  eps.rel = 0.01,
  var.j = FALSE,
  zeta = 10,
  incr = 2,
  eta.j = 0.32,
  BQ2.eva,
  compute.vc = TRUE,
  Br = 500,
  level = 0.05,
  eta.hat,
  gamma.hat,
  biascorr = TRUE
)
}
\arguments{
\item{h}{smoothing bandwidth}

\item{tau}{quantile level}

\item{Y}{response variable}

\item{C}{covariates with constant effects}

\item{X}{covariates with varying coefficients}

\item{B}{Bernstein basis polynoimials. An object from basis() in package BPST.}

\item{Q2}{Q2 matrix from the QR decomposition of the smoothness matrix of triangles}

\item{lambda}{the penalization parameter}

\item{eps.abs}{first convergence criterion of ADMM}

\item{eps.rel}{second convergence criterion of ADMM}

\item{var.j}{whether to vary the step size in the ADMM}

\item{zeta}{criterion for the step size to increment if stepsize is set to vary}

\item{incr}{factor of increment for step size if stepsize is set to vary}

\item{eta.j}{step size. Set it to be 1 if var.j = TRUE}

\item{BQ2.eva}{the basis to be evaluated. It can be the basis function for the locations to be predicted.}

\item{compute.vc}{whether to compute the pointwise confidence intervals for the varying coefficient. If TRUE, BQ2.eva must be provided.}

\item{Br}{the number of bootstrap replications}

\item{level}{significance level}

\item{biascorr}{whether to apply bias correction using Bahadur representation of the SQBiT estimator}
}
\value{
A list with components:
\describe{
\item{\code{etas}}{The estimated constant coefficients from bootstrap replications.}
\item{\code{cis}}{The wild bootstrap confidence intervals for the constant coefficients.}
\item{\code{betas.lb}}{The lower bound for the varying coefficient.}
\item{\code{betas.ub}}{The upper bound for the varying coefficient.}
\item{\code{time}}{Computational time used.}
}
}
\description{
This function performs wild bootstrap inference for quantile spatial model (QSM) with initial estimates from output from SQBiT. It returns the confidence intervals for constant coefficients and varying coefficients. If the basis function for the locations to be predicted is provided, it also computes the confidence intervals for the given locations.
}
\details{
\strong{What is Quantile Spatial Model (QSM)?}

The proposed Quantile Spatial Model (QSM) is given by:
\deqn{
Q_{\tau}(Y_i \mid \mathbf{C}_i,\mathbf{X}_i, \mathbf{S}_i) = \mathbf{C}_i^{\top} \boldsymbol{\eta}_{\tau}
+ \sum_{j=0}^p X_{ij} \beta_{j,\tau}(\mathbf{S}_i), \quad i = 1, \ldots, n.
}
where \eqn{Q_Y(\tau \mid \cdot) = \inf\{y: P(Y \leq y \mid \cdot) \geq \tau\}} denotes the
\eqn{\tau}th (\eqn{\tau \in (0, 1)}) conditional quantile of \eqn{Y},
\eqn{\boldsymbol{\eta}_{\tau} = (\eta_{1,\tau}, \ldots, \eta_{q,\tau})^{\top}} captures the constant effects,
and \eqn{\beta_{j,\tau} \colon \Omega \mapsto \mathbb{R}} is the unknown spatially varying coefficient function.
\cr

This semi-parametric model captures spatial heterogeneity through the spatially varying
coefficients \eqn{\beta_{j,\tau}(\cdot)}, and non-spatial covariate effects through the
constant coefficients \eqn{\eta_{\ell,\tau}}. The partially linear nature of the model offers both flexibility and interpretability.

\strong{How to use QSM?}

In general, there are four steps to analyze spatial data using QSM.
\enumerate{
\item Create a triangulation mesh for your spatial domain. This can be done using "Triangulation" package. It can be downloaded in github using install_github("funstatpackages/Triangulation").
\item Generate the bivariate triangulation spline given a degree of polynomials \eqn{d} and a smoothness parameter \eqn{r}. This can be done using "BPST". It can be downloaded in github using install_github("FIRST-Data-Lab/BPST").
\item Fit QSM using SQBiT.
\item Plot the estimates for the varying coefficient.
}

\strong{Optimization:}

The optimization is based on alternating direction method of multipliers (ADMM). For the algorithmic details, we refer users to Boyd et al (2011). Note that it has been shown that the algorithm will converge under mild conditions even if a fixed step size is used for ADMM.

\strong{Inference:}

The inference for SQBiT can be conducted using wild bootstrap. We refer to Feng et al (2011) for the details of wild bootstrap for quantile regression. Bias correction can be applied by specifying bias.corr = TRUE, which employs the Bahadur representation of SQBiT. Note that in our investigation, we found that the coverage using penalization parameters selected k-fold CV tends to be more stable than those by GACV.
}
\examples{
\donttest{
###### Step 1. Create a Triangulation Mesh
boundaries <- matrix(c(0, 0,
                       0, 1,
                       1, 1,
                       1, 0), nrow = 4, byrow = TRUE)
tri <- TriMesh(boundaries, n = 8)
Tr <- tri$Tr
V <- round(tri$V, 3)

# Population locations
s1 <- runif(10000)
s2 <- runif(10000)
S_pop <- data.frame(s1 = s1, s2 = s2)

# Determine which points are inside triangulation
ind1 <- inVT(V0 = V, Tr0 = Tr, xx = S_pop[,1], yy = S_pop[,2])
ind1 <- ind1$ind.inside
ind2 <- (1:nrow(S_pop))[!is.na(S_pop[,1])]
ind <- sort(intersect(ind1, ind2))
pop.r <- S_pop[ind, ]
Npop <- nrow(pop.r)

# Coordinates and coefficient functions
S.pop <- pop.r[, c(1, 2)]
beta1 <- function(s1, s2) sin(pi * s1 * s2)
beta2 <- function(s1, s2) (1 - (1 - 2 * s1)^2) * (1 - (1 - 2 * s2)^2)
pop.r <- cbind(S.pop, beta1(S.pop[,1], S.pop[,2]), beta2(S.pop[,1], S.pop[,2]))
colnames(pop.r)[3:4] <- c('beta0', 'beta1')

####### Step 2. Generate bivariate triangulation basis
d <- 3
r <- 1
B0.pop <- basis(V = V, Tr = Tr, d = d, r = r, Z = as.matrix(S.pop))
Q2 <- B0.pop$Q2
B.pop <- B0.pop$B
K <- B0.pop$K
P <- t(Q2) \%*\% K \%*\% Q2

# Simulation parameters
n <- 2000
tau <- 0.5
eta <- matrix(c(1, 1, 1))
Sigma <- diag(3)

# Sample population and simulate covariates
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
S <- data[, c(1, 2)]
C <- matrix(runif(3 * n, -1, 1), ncol = 3)
X <- matrix(runif(n, -1, 1), n, 1)
beta0 <- data[, c('beta0', 'beta1')]
Y <- beta0[,1] + X[,1] * beta0[,2] + C \%*\% eta + rnorm(n = n)

####### Step 3. Estimate QSM using SQBiT
X <- cbind(1, X)
B <- B.pop[ind.s, ]
lambda.cv <- SQBiT_cv(Y = Y, X = X, C = C, P = P, B = B, Q2 = Q2, tau = tau)
mod <- SQBiT(Y = Y, X = X, C = C, P = P, B = B, Q2 = Q2, lambda = lambda.cv$lambda, tau = tau)
wb.est <- SQBiT_wb(tau = tau, Y = Y, C = C, X = X, P = P, B = B, Q2 = Q2, lambda = lambda.cv$lambda,
                   compute.vc = TRUE, BQ2.eva = BQ2.pop, eta.hat = mod$eta, gamma.hat = mod$gamma)
cis <- wb.est$cis        ### confidence intervals for constant coefficients
vc.lb <- wb.est$betas.lb ### lower bound for varying coefficients
vc.ub <- wb.est$betas.ub ### upper bound for varying coefficients

####### Step 4. Plot varying coefficient
p <- ncol(X)
q <- ncol(C)
Jn <- dim(B.pop \%*\% Q2)[2]
mhat.sm <- c()
for(i in 1:p){
 mhat.sm <- cbind(mhat.sm, BQ2.pop \%*\% mod$gamma[(1 + (i - 1) * Jn):(Jn * i)])
}

####### replace mhat.sm[, 2] with vc.lb[, 2] or vc.ub[, 2] for lower bound or upper bound of confidence intervals
interp_result <- interp(x = S.pop[, 1], y = S.pop[, 2], duplicate = "mean",
                       z = mhat.sm[, 2], nx = 140, ny = 140)
interp_df <- with(interp_result, expand.grid(x = x, y = y))
interp_df$z <- as.vector(interp_result$z)

# Plot smooth heatmap
ggplot(interp_df, aes(x = x, y = y, fill = z)) +
 geom_raster(interpolate = TRUE) +
 scale_fill_gradient(limits = c(0, 1),
                     low = "deepskyblue",
                     high = "magenta",
                     oob = scales::squish) +
 labs(
   x = "$s_1$",
   y = "$s_2$",
   z = "$\\\\beta_1(\\\\boldsymbol{s})$",
   fill = "$\\\\beta_1(\\\\boldsymbol{s})$"
 ) +
 coord_fixed() +
 theme_minimal() +
 theme(panel.grid = element_blank(),
       plot.title = element_text(hjust = 0.5))
}

}
\references{
Kim, M., Wang, L., and Wang, H. J. (2025). Estimation and inference of quantile spatially varying coefficient models over complicated domains. \emph{Journal of the American Statistical Association}, 1--15. Taylor & Francis. Forthcoming.

He, X., Pan, X., Tan, K.M., & Zhou, W.-X. (2023). Smoothed quantile regression with large-scale inference. \emph{Journal of Econometrics}, 232(2), 367â€“388.

Boyd, S., Parikh, N., Chu, E., Peleato, B., Eckstein, J., and others (2011). Distributed optimization and statistical learning via the alternating direction method of multipliers. \emph{Foundations and Trends in Machine Learning}, 3(1), 1--122. Now Publishers.

Yuan, M. (2006). GACV for quantile smoothing splines. \emph{Computational Statistics & Data Analysis}, 50(3), 813-829.

Feng, X., He, X., & Hu, J. (2011). Wild bootstrap for quantile regression. \emph{Biometrika}, 98(4), 995-999.
}
